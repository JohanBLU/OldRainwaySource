version=pmwiki-2.2.138 ordered=1 urlencoded=1
author=MFWolff
charset=UTF-8
csum=e modifier deprecation (+181)
ctime=1396452831
name=PmWikiDe.CustomMarkupAlt
rev=11
targets=PmWikiDe.LocalCustomizations,PmWikiDe.GroupCustomizations,PmWikiDe.CustomMarkup,PmWikiDe.LayoutVariables,Cookbook.CleanUrls,PmWikiDe.AvailableActions,PmWikiDe.SecurityVariables,Category.PmWikiDeveloper
text=(:title (alternative) Einführung in eigene Markups :)%0a(:Summary: Eine (alternative) Einführung in eigene Markups für Anfänger:)%0a(:Original_Page: PmWiki.{$Name}:)%0a(:Translation_Date: 2014-04-02:)%0a(:Translation_Status: %25green%25fertig%25%25:)%0a(:Audience: Administratoren:)%0a%0aEine ganz typische Art eines "PlugIns" &ndash; Ich werde es von hier an "Rezept" nennen, weil das die Bezeichnung in der PmWiki-Welt ist &ndash; dient dazu, eine eigene Markup-Regel zu einzurichten. Das bedeutet, Sie definieren ein gewisses besonderes Textmuster in Ihrer Seite, das eine gewisse Aktion auslöst und bewirkt, dass das gewisse Textmuster durch einen anderen Text ersetzt wird.%0a%0a-->%25green%25(Wenn Sie ''eigene Aktionen'' entwerfen wollen, [[#customaction|dann klicken Sie hier]].)%25%25%0a%0a!! Ein simples Beispiel%0a%0aDas einfachste mögliche Markup ist eine bloße Ersetzung. Hier ist ein Markup, das jedes Vorkommen des Buchstaben "a" durch den Buchstaben "z" ersetzt:%0a%0a[@Markup('a2z', '>{$var}', '/a/', 'z');@]%0a%0aDaraufhin wird Ihre Seite mit diesem (Quell-)Text:%0a%0a>>frame%3c%3c%0aThe alphabet begins with "abc"%0a>>%3c%3c%0a%0adiese hier ausgeben:%0a%0a>>frame%3c%3c%0aThe zlphzbet begins with "zbc"%0a>>%3c%3c%0a%0aDas ist zwar nicht gerade nützlich, aber es gibt eine Idee davon, was ein Markuptext so macht.%0a%0aDas Erzeugen eines neuen Markups hat mit dem Aufruf der Funktion Markup() zu tun. Dies wird gewöhnlich durch das Bearbeiten Ihrer ''config.php'' erreicht, Sie können es aber auch in eine eigene Gruppen- oder Seiten-PHP-Datei einfügen &mdash; nachzulesen unter [[PmWikiDe/LocalCustomizations|+]] und [[PmWikiDe/GroupCustomizations|+]]. %0a%0aDie Markup()-Funktion nimmt vier Argumente entgegen:%0a%0a# Den besonderen Namen, den Sie Ihrem Markup geben. Er soll kurz, aber beschreibend sein. Achten Sie darauf, dass Sie nicht den Namen eines bestehenden Markups verwenden, jenes wird dann seinen Dienst versagen. (Sie können die Standarddefinitionen in ''scripts/stdmarkup.php'' finden.)%0a%0a# Einen Anzeiger, WANN dies auftreten soll. PmWiki hat Dutzende von diesen Regeln und es macht einen großen Unterschied, in welcher Reihenfolge die auftreten. Wenn die eine Regel (#1) jedes "a" in ein "b" verwandelt und eine weitere (#2) jedes "az" in "zz", ist es offensichtlich, dass es einen großen Unterschied macht, in welcher Reihenfolge sie aufgerufen werden. Wenn #1 vor #2 auftritt, wird der Text "azazaz" zu "bzbzbz". Wenn aber #2 vor #1 auftritt, enden Sie bei "zzzzzz". Dieser Anzeiger wird normalerweise angegeben durch eine öffnende spitze Klammer (vorher) oder eine schließende spitze Klammer (hinterher), gefolgt von dem Namen einer Regel. Nach meiner Erfahrung ist die wichtigste Regel in Sachen Reihenfolge [="{$var}"=], die Variablen ersetzt &mdash; wenn Sie [="%3c{$var}"=] eintragen, wird Ihre Regel vor der Variablenersetzung angewendet, wenn Sie [=">{$var}"=] eintragen, wird Ihre Regel nach der Variablenersetzung angewendet. %0a%0a->Aber es gibt noch jede Menge anderer Stellen in der Regelreihenfolge &mdash; jemand anderes muss da mehr ins Detail gehen, wenn Sie es brauchen. Jene Seite mit [[PmWikiDe/CustomMarkup|eigenen Auszeichnungen]] gibt ein paar gute Anhalte dazu.%0a%0aArgument 3 und 4 sind einfach Argumente, die an die preg_replace-Funktion weitergereicht werden. Die sucht nach Argument #3 und ersetzt es mit Argument #4%0a%0a# %25item value=3%25 Der Suchstring in ein regulärer Ausdruck. Er kann so einfach sein wie "/a/", (passt auf jedes vorkommende Zeichen "a") bis hin zu sehr umfangreichen und komplizierten Ausdrücken. Jedesmal, wenn dies Muster auf ihren Text passt, wird es ersetzt mit dem Argument #4. Beachten Sie, dass Ihr Muster immer von Vorwärtsschrägstrichen umgeben ist und dass dem schließenden Schrägstrich noch Modifier folgen können. Die Modifier sind einzelne Buchstaben, über die Sie mehr lesen können unter http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php.  Die wichtigsten sind %0a** "i" &rarr; ignoriert Groß/Kleinschreibung, %0a** "s" &rarr; ein Punkt passt auch auf Zeilenumbrüche, %0a** "m" &rarr; die Anker "^" und "$" passen nicht nur auf den Beginn und das Ende der Zeichenkette, sondern auch vor und hinter Zeilenümbrüchen &mdash; also auf Zeilenanfang und -Ende &mdash; und (vielleicht das wichtigste in diesem Zusammenhang), %0a** "e" &rarr; wertet den Ersetzungstext als PHP-Ausdruck aus &mdash; das erlaubt es, Funktionen aufzurufen, die kompliziertere Sachen machen als nur ein einfaches Suchen&Ersetzen.%0a%0a# Dies ist der Ersetzungstext. Er kann eine einfache Zeichenkette sein oder er kann Dinge wie $1, $2 etc. enthalten, wenn Sie Klammergruppen in Ihrem dritten Argument haben (Sie müssen darauf achten, einen Backslash vor das $-Zeichen zu setzen oder das Argument in ''einfache'' Anführungszeichen zu setzen etc., um eine frühzeitige Auswertung von Variablen zu verhindern). Oder er kann ein Aufruf einer PHP-Funktion sein, wenn Sie den /e-Modifier in Argument #3 benutzt haben. %0a%0aNachdem das alles gesagt ist, ist der beste Weg zu lernen, eigene Rezepte oder Markups zu schreiben, ein Blick auf Beispiele zu werfen, wie andere Leute so etwas gemacht habe.%0a%0a!!Die [@(:comment ...:)@]-Markup-Regel%0aHier ist die Definition der Regel für das [@(:comment ...:)@]-Markup aus ''scripts/stdmarkup.php'':%0a%0a[@Markup('comment', 'directives', '/\\(:comment .*?:\\)/i', '');@]%0a%0aDer Sinn dieses Markups ist, dass Sie Text in ihren Quelltext einfügen können, der nicht erscheint, wenn die Seite im Browser angezeigt wird. Lassen Sie uns die Argumente betrachten:%0a*ARG1: [@'comment'@] &mdash; ein kurzer, beschreibender Name  - die ID der Regel%0a*ARG2: [@'directives'@] &mdash; das ist eine von 9 Phasen, die die Antwort geben auf die Frage, wann meine Regel angewendet werden soll.%0a*ARG3: [@'/\\(:comment .*?:\\)/i'@] &mdash; dies ist der reguläre Ausdruck, der auf [@(:comment ANY TEXT HERE:)@] passt &mdash; dies ist das Muster, nach dem gesucht wird. Da der letzte Schrägstrich von einem i gefolgt wird ("/i"), passt genauso gut auch [@(:COMMENT some text:)@] und [@(:CoMmEnT some text:)@] &mdash; Groß/Kleinschreibung wird von dem Suchmuster nicht unterschieden. %0a*ARG4: [@''@] &mdash; jedes Auftreten des Musters wird ersetzt durch ... NICHTS. So verschwindet der Kommentar einfach, was genau das ist, was Sie wollten.%0a%0a!!Die [@(:include ...:)@]-Markup-Regel%0aLassen Sie uns noch ein weiteres Beispiel aus ''stdmarkup.php'' ansehen, die [@(:include PAGENAME:)@]-Markup-Regel. Die Regel ist gemacht, um Text aus einer anderen Seite in die Seite hineinzuziehen. Hier ist die Definition aus ''stdmarkup.php'':%0a%0a[@Markup('include', '>if',%0a  '/\\(:include\\s+(\\S.*?):\\)/ei',%0a  "PRR(IncludeText(\$pagename, PSS('$1')))");%0a@]%0a%0a%25red%25'''Warnung''': Der /e Modifizierer ist schon seit Jahren überholt (und endgültig entfernt mit PHP7.2). Für Details, wie er zu ersetzen ist, siehe [[CustomMarkup#php55|+]].%0a%0aDie Argumente der Reihe nach:%0a*ARG1: [@'include'@] &mdash; kurzer beschreibender Name dafür, was die Regel tut.%0a*ARG2: [@'>if'@] &mdash; wende diese Regel nach der Regel mit der ID 'if' an%0a*ARG3: [@'/\\(:include\\s+(\\S.*?):\\)/ei'@] &mdash; dieser reguläre Ausdruck passt auf ein Muster [@(:include pagename:)@], in dem "pagename" irgend eine Folge von Nicht-Whitespace-Zeichen ist. (Whitespace ist ein Leerzeichen, ein Tabulator- oder ein Zeilenvorschub-Zeichen). Die wichtige Änderung ist das /ei am Ende. Sie wissen schon, dass das "i" am Ende bedeutet, dass die Groß/Kleinschreibung ignoriert wird. Das "e" bedeutet, dass der Ersatztext ein PHP-Ausdruck ist, der ausgewertet werden soll. (Es bedeutet auch, dass ein Bündel von Backslashes bestimmten Zeichen vorangestellt wird, die von dem Suchmuster kommen, wenn Sie Klammern zum Einfangen von Regex-Mustern benutzen.) Beachten Sie, dass das "\\S.*?" von Klammern umgeben wird, was bedeutet, dass die Fundstelle gegriffen und dem Ersetzungsstring als $1 zur Verfügung gestellt wird.%0a*ARG4: [@"PRR(IncludeText(\$pagename, PSS('$1')))"@] &mdash; hierdurch wird das Suchmuster ersetzt. Da aber oben dieses "e" vorhanden ist, wird dieser Text als PHP-Ausdruck interpretiert. Beachten Sie ein paar Dinge über diesen Text, die wirklich wichtig sind:%0a**Jegliche Variablennamen werden vor unmittelbarer Ersetzung geschützt, entweder durch Voranstellen eines Backslashes vor das Dollarzeichen oder durch das Setzen von einfachen Anführungszeichen um das Argument herum.%0a**Die Funktion PSS('$1') "Strips Slashes" &mdash; sie wird die Slashes wieder los, die durch die obige /e-Option gesetzt wurden.%0a** Die Funktion IncludeText() ist eine PmWiki-Funktion, die zwei Argumente annimmt (einen Referenzseitennamen und den Seitennamen des Textes, der behandelt werden soll) und sie liefert den Text dieser Seite zurück. Das bedeutet, dass das [@(:include pagename:)@] in Ihrer Quelle ersetzt wird durch den Text jener Seite.%0a** Das umgebende PRR() weist PmWiki an, noch einmal alle Markup-Regeln durch zu gehen, für den Fall, dass etwas aus dem eingefügten Text hinzugekommen ist, das von bereits durchgelaufenen Regeln bearbeitet werden sollte. PRR() liefert immer den Wert seines Argumentes zurück, es ist so eine Art transparente Funktion mit einem Seiteneffekt.%0a%0a!!Die [@(:nogroupheader:)@]-Markup-Regel%0aDiese Markup-Regel dient dazu, die Anzeige des GroupHeader zu unterdrücken. Damit das geschieht, muss die globale Variable $GroupHeaderFmt mit einer leeren Zeichenkette gefüllt werden. Hier ist die Markup-Definition.%0a%0a[@Markup('nogroupheader', '>include',%0a  '/\\(:nogroupheader:\\)/ei',%0a  "PZZ(\$GLOBALS['GroupHeaderFmt']='')");%0a@]%0a%0a*ARG1: [@'nogroupheader'@] &mdash; kurzer Name, beschreibt, was diese Regel tut.%0a*ARG2: [@'>include'@] &mdash; wende diese Regel nach der Regel mit der ID 'include' an (ja, das ist die Regel, die wir gerade betrachtet haben).%0a*ARG3: [@'/\\(:nogroupheader:\\)/ei'@] &mdash; ein wirklich einfacher regulärer Ausdruck mit der gleichen /ei-Option wie oben.%0a*ARG4: [@"PZZ(\$GLOBALS['GroupHeaderFmt']='')"@]%0a** Und wieder ist die Variable durch escapen des Dolllarzeichens vor der Interpretion geschützt (durch Voranstellen eines Backslashes).%0a** Auf die globale Variable $GroupHeaderFmt wird mit der PHP-Super-Globalen $GLOBALS[] zugegriffen.%0a** Der Kern dieser Regel hat diesen Text: [@$GLOBALS['GroupHeaderFmt']=''@] &mdash; das setzt den Wert auf die leere Zeichenkette.%0a** Das umgebende PZZ() sagt einfach, werde jeglichen Rückgabewert los &mdash; das Suchmuster wird durch die leere Zeichenkette ersetzt.%0a%0a[[#customaction]]%0a!!Eigene Aktionen%0a%0aEine Aktion wird ausgeführt durch das Anhängen von "?action=MYACTION" an das Ende des URL. Die Standardaktion ist stets "browse", wenn Sie also keine Aktion in Ihrer Adressleiste sehen, dann nimmt PmWiki an, Sie meinten "http://www.example.com/pmwiki/...?action=browse".%0a%0aWenn Sie zum Beispiel [[Cookbook:CleanUrls]] benutzen und auf die Seite %0a->@@http://www.example.com/pmwiki/Mygroup/Mypage@@%0azugreifen wollen, aber auch die Aktion "source" (die zeigt den Quelltext der Seite) ausführen möchten, dann benutzen Sie %0a->@@http://www.example.com/pmwiki/Mygroup/Mypage?action=source@@%0a%0aWenn Sie aber NICHT die CleanUrls benutzen und wollen auf die Seite %0a->@@http://www.example.com/pmwiki/pmwiki.php?n=Mygroup.Mypage@@%0azugreifen und dabei die Aktion "edit" (damit "bearbeiten" Sie die Seite) ausführen möchten, dann benutzen Sie %0a->@@http://www.example.com/pmwiki/pmwiki.php?n=Mygroup.Mypage?action=edit@@%0a(Das ist eine alternative Methode, eine Seite zu bearbeiten, wenn es keinen Verweis dafür gibt.)%0a%0aEs gibt mehrere andere [[PmWikiDe/AvailableActions|eingebaute Aktionen]], aber manchmal ist es bequemer (als Entwickler), eine eigenen Aktionen hinzuzufügen.%0a%0aWenn Sie eine Aktion "meineAktion" hinzufügen wollten, und riefen dazu die Funktion @@BehandleMeineAktion()@@ auf, dann schrieben Sie diesen Kode in Ihre ''config.php'' oder in Ihr Rezeptskript:%0a%0a>>frame%3c%3c%0a[@%0a$HandleActions['meineAktion'] = 'BehandleMeineAktion';%0a%0a$HandleAuth['meineAktion'] = 'admin';%0a%0afunction BehandleMeineAktion($pagename, $auth) {%0a   $page = RetrieveAuthPage($pagename, $auth);%0a   if (!$page) {%0a      ...%0a   }%0a   ...%0a}%0a@]%0a>>%3c%3c%0a%0aBeachten Sie, dass das  $HandleAuth[]-Array bestimmt, welche Standardautorisierung als zweites Argument an Ihre eigenen Aktion übergeben wird. Sie sind dafür verantwortlich, diese Autorisierung durchzusetzen (typischerweise durch @@CondAuth()@@ oder @@RetrieveAuthPage()@@).%0a%0aWeitere interessante Seiten finden Sie in der [[!PmWiki Developer]]-Kategorie.%0a%0a
time=1618814240
title=(alternative) Einführung in eigene Markups 
